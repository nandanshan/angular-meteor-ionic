{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-meteor-auth.min.js","webpack:///webpack/bootstrap ab00880673cc01d61697","webpack:///./src/angular-meteor-auth.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","name","angular","$Mixer","$log","$$Auth","vm","arguments","length","undefined","autorun","currentUser","Meteor","user","currentUserId","userId","isLoggingIn","loggingIn","Accounts","Package","Error","errors","required","forbidden","$awaitUser","validate","_this","$bindToContext","caller","_","isFunction","deferred","$$defer","computation","getReactively","stop","$$afterFlush","reject","isValid","resolve","error","isString","promise","bind","fn","_fn","_len","args","Array","_key","Tracker","afterFlush","apply","concat","$waitForUser","err","debug","$requireUser","$requireValidUser","service","$rootScope","_this2","keys","forEach","k","stripped","substr","run","mixin"],"mappings":"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","file":"dist/angular-meteor-auth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteorAuth\"] = factory();\n\telse\n\t\troot[\"angularMeteorAuth\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! angular-meteor-auth v1.0.3 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteorAuth\"] = factory();\n\telse\n\t\troot[\"angularMeteorAuth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar name = 'angular-meteor.auth';\n\texports.default = name;\n\t\n\t\n\tangular.module(name, ['angular-meteor.mixer', 'angular-meteor.scope', 'angular-meteor.core', 'angular-meteor.view-model', 'angular-meteor.reactive'])\n\t\n\t/*\n\t  A mixin which provides us with authentication related methods and properties.\n\t  This mixin comes in a seperate package called `angular-meteor-auth`. Note that `accounts-base`\n\t  package needs to be installed in order for this module to work, otherwise an error will be thrown.\n\t */\n\t.factory('$$Auth', ['$Mixer', '$log', function ($Mixer, $log) {\n\t  var Accounts = (Package['accounts-base'] || {}).Accounts;\n\t\n\t  if (!Accounts) {\n\t    throw Error('`angular-meteor.auth` module requires `accounts-base` package, ' + 'please run `meteor add accounts-base` before use');\n\t  }\n\t\n\t  var errors = {\n\t    required: 'AUTH_REQUIRED',\n\t    forbidden: 'FORBIDDEN'\n\t  };\n\t\n\t  function $$Auth() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // Reset auth properties\n\t    this.autorun(function () {\n\t      // Note that we use Meteor and not Accounts since the following methods are\n\t      // not available in older versions of `accounts-base` meteor package\n\t      vm.currentUser = Meteor.user();\n\t      vm.currentUserId = Meteor.userId();\n\t      vm.isLoggingIn = Meteor.loggingIn();\n\t    });\n\t  }\n\t\n\t  // Waits for user to finish the login process. Gets an optional validation function which\n\t  // will validate if the current user is valid or not. Returns a promise which will be rejected\n\t  // once login has failed or user is not valid, otherwise it will be resolved with the current\n\t  // user\n\t  $$Auth.$awaitUser = function (validate) {\n\t    var _this = this;\n\t\n\t    validate = validate ? this.$bindToContext($Mixer.caller, validate) : function () {\n\t      return true;\n\t    };\n\t\n\t    if (!_.isFunction(validate)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t\n\t    var deferred = this.$$defer();\n\t\n\t    // Note the promise is being fulfilled in the next event loop to avoid\n\t    // nested computations, otherwise the outer computation will cancel the\n\t    // inner one once the scope has been destroyed which will lead to subscription\n\t    // failures. Happens mainly after resolving a route.\n\t    var computation = this.autorun(function (computation) {\n\t      if (_this.getReactively('isLoggingIn')) return;\n\t      // Stop computation once a user has logged in\n\t      computation.stop();\n\t\n\t      if (!_this.currentUser) return _this.$$afterFlush(deferred.reject, errors.required);\n\t\n\t      var isValid = validate(_this.currentUser);\n\t      // Resolve the promise if validation has passed\n\t      if (isValid === true) return _this.$$afterFlush(deferred.resolve, _this.currentUser);\n\t\n\t      var error = void 0;\n\t\n\t      if (_.isString(isValid) || isValid instanceof Error) {\n\t        error = isValid;\n\t      } else {\n\t        error = errors.forbidden;\n\t      }\n\t\n\t      return _this.$$afterFlush(deferred.reject, error);\n\t    });\n\t\n\t    var promise = deferred.promise;\n\t    promise.stop = computation.stop.bind(computation);\n\t    return promise;\n\t  };\n\t\n\t  // Calls a function with the provided args after flush\n\t  $$Auth.$$afterFlush = function (fn) {\n\t    var _fn;\n\t\n\t    if (_.isString(fn)) {\n\t      fn = this[fn];\n\t    }\n\t\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    return Tracker.afterFlush((_fn = fn).bind.apply(_fn, [this].concat(args)));\n\t  };\n\t\n\t  // API v0.2.0\n\t  // Aliases with small modificatons\n\t\n\t  // No validation\n\t  // Silent error\n\t  $$Auth.$waitForUser = function () {\n\t    // Silent error\n\t    return this.$awaitUser().catch(function (err) {\n\t      $log.debug('user login has failed (' + err + ')');\n\t    });\n\t  };\n\t\n\t  // No validation\n\t  $$Auth.$requireUser = function () {\n\t    return this.$awaitUser();\n\t  };\n\t\n\t  // Full functionality\n\t  $$Auth.$requireValidUser = function () {\n\t    return this.$awaitUser.apply(this, arguments);\n\t  };\n\t\n\t  return $$Auth;\n\t}])\n\t\n\t/*\n\t  External service for syntactic sugare.\n\t  Originally created as UI-router's resolve handler.\n\t */\n\t.service('$auth', ['$rootScope', '$$Auth', function ($rootScope, $$Auth) {\n\t  var _this2 = this;\n\t\n\t  // Note that services are initialized once we call them which means that the mixin\n\t  // will be available by then\n\t  _.keys($$Auth).forEach(function (k) {\n\t    var stripped = k.substr(1);\n\t    // Not using bind() so it would be testable\n\t    _this2[stripped] = function () {\n\t      return $rootScope[k].apply($rootScope, arguments);\n\t    };\n\t  });\n\t}]).run(['$Mixer', '$$Auth', function ($Mixer, $$Auth) {\n\t  $Mixer.mixin($$Auth);\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-meteor-auth.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ab00880673cc01d61697\n **/","const name = 'angular-meteor.auth';\nexport default name;\n\nangular.module(name, [\n  'angular-meteor.mixer',\n  'angular-meteor.scope',\n  'angular-meteor.core',\n  'angular-meteor.view-model',\n  'angular-meteor.reactive'\n])\n\n/*\n  A mixin which provides us with authentication related methods and properties.\n  This mixin comes in a seperate package called `angular-meteor-auth`. Note that `accounts-base`\n  package needs to be installed in order for this module to work, otherwise an error will be thrown.\n */\n.factory('$$Auth', [\n  '$Mixer',\n  '$log',\n\nfunction($Mixer, $log) {\n  const Accounts = (Package['accounts-base'] || {}).Accounts;\n\n  if (!Accounts) {\n    throw Error(\n      '`angular-meteor.auth` module requires `accounts-base` package, ' +\n      'please run `meteor add accounts-base` before use'\n    );\n  }\n\n  const errors = {\n    required: 'AUTH_REQUIRED',\n    forbidden: 'FORBIDDEN'\n  };\n\n  function $$Auth(vm = this) {\n    // Reset auth properties\n    this.autorun(() => {\n      // Note that we use Meteor and not Accounts since the following methods are\n      // not available in older versions of `accounts-base` meteor package\n      vm.currentUser = Meteor.user();\n      vm.currentUserId = Meteor.userId();\n      vm.isLoggingIn = Meteor.loggingIn();\n    });\n  }\n\n  // Waits for user to finish the login process. Gets an optional validation function which\n  // will validate if the current user is valid or not. Returns a promise which will be rejected\n  // once login has failed or user is not valid, otherwise it will be resolved with the current\n  // user\n  $$Auth.$awaitUser = function(validate) {\n    validate = validate ? this.$bindToContext($Mixer.caller, validate) : () => true;\n\n    if (!_.isFunction(validate)) {\n      throw Error('argument 1 must be a function');\n    }\n\n    const deferred = this.$$defer();\n\n    // Note the promise is being fulfilled in the next event loop to avoid\n    // nested computations, otherwise the outer computation will cancel the\n    // inner one once the scope has been destroyed which will lead to subscription\n    // failures. Happens mainly after resolving a route.\n    const computation = this.autorun((computation) => {\n      if (this.getReactively('isLoggingIn')) return;\n      // Stop computation once a user has logged in\n      computation.stop();\n\n      if (!this.currentUser) return this.$$afterFlush(deferred.reject, errors.required);\n\n      const isValid = validate(this.currentUser);\n      // Resolve the promise if validation has passed\n      if (isValid === true) return this.$$afterFlush(deferred.resolve, this.currentUser);\n\n      let error;\n\n      if (_.isString(isValid) || isValid instanceof Error) {\n        error = isValid;\n      }\n      else {\n        error = errors.forbidden;\n      }\n\n      return this.$$afterFlush(deferred.reject, error);\n    });\n\n    const promise = deferred.promise;\n    promise.stop = computation.stop.bind(computation);\n    return promise;\n  };\n\n  // Calls a function with the provided args after flush\n  $$Auth.$$afterFlush = function(fn, ...args) {\n    if (_.isString(fn)) {\n      fn = this[fn];\n    }\n\n    return Tracker.afterFlush(fn.bind(this, ...args));\n  };\n\n  // API v0.2.0\n  // Aliases with small modificatons\n\n  // No validation\n  // Silent error\n  $$Auth.$waitForUser = function() {\n    // Silent error\n    return this.$awaitUser().catch((err) => {\n      $log.debug(`user login has failed (${err})`);\n    });\n  };\n\n  // No validation\n  $$Auth.$requireUser = function() {\n    return this.$awaitUser();\n  };\n\n  // Full functionality\n  $$Auth.$requireValidUser = function(...args) {\n    return this.$awaitUser(...args);\n  };\n\n  return $$Auth;\n}])\n\n/*\n  External service for syntactic sugare.\n  Originally created as UI-router's resolve handler.\n */\n.service('$auth', [\n  '$rootScope',\n  '$$Auth',\n\nfunction($rootScope, $$Auth) {\n  // Note that services are initialized once we call them which means that the mixin\n  // will be available by then\n  _.keys($$Auth).forEach((k) => {\n    const stripped = k.substr(1);\n    // Not using bind() so it would be testable\n    this[stripped] = (...args) => $rootScope[k](...args);\n  });\n}])\n\n.run([\n  '$Mixer',\n  '$$Auth',\n\nfunction($Mixer, $$Auth) {\n  $Mixer.mixin($$Auth);\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/angular-meteor-auth.js\n **/"],"sourceRoot":""}